// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data/db/proto/recipes.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type FileType int32

const (
	FileType_REGULAR FileType = 0
	FileType_SYMLINK FileType = 1
)

var FileType_name = map[int32]string{
	0: "REGULAR",
	1: "SYMLINK",
}
var FileType_value = map[string]int32{
	"REGULAR": 0,
	"SYMLINK": 1,
}

func (x FileType) String() string {
	return proto1.EnumName(FileType_name, int32(x))
}
func (FileType) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

type RecipeTagType int32

const (
	RecipeTagType_EDIT    RecipeTagType = 0
	RecipeTagType_OPTIMAL RecipeTagType = 1
	// 2 is reserved for Temp
	RecipeTagType_REWRITTEN RecipeTagType = 3
)

var RecipeTagType_name = map[int32]string{
	0: "EDIT",
	1: "OPTIMAL",
	3: "REWRITTEN",
}
var RecipeTagType_value = map[string]int32{
	"EDIT":      0,
	"OPTIMAL":   1,
	"REWRITTEN": 3,
}

func (x RecipeTagType) String() string {
	return proto1.EnumName(RecipeTagType_name, int32(x))
}
func (RecipeTagType) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

type RecipeRTag struct {
	Id   string        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Type RecipeTagType `protobuf:"varint,2,opt,name=type,enum=wm.data.db.RecipeTagType" json:"type,omitempty"`
}

func (m *RecipeRTag) Reset()                    { *m = RecipeRTag{} }
func (m *RecipeRTag) String() string            { return proto1.CompactTextString(m) }
func (*RecipeRTag) ProtoMessage()               {}
func (*RecipeRTag) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *RecipeRTag) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RecipeRTag) GetType() RecipeTagType {
	if m != nil {
		return m.Type
	}
	return RecipeTagType_EDIT
}

type RecipeWTag struct {
	Id   string        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Type RecipeTagType `protobuf:"varint,2,opt,name=type,enum=wm.data.db.RecipeTagType" json:"type,omitempty"`
}

func (m *RecipeWTag) Reset()                    { *m = RecipeWTag{} }
func (m *RecipeWTag) String() string            { return proto1.CompactTextString(m) }
func (*RecipeWTag) ProtoMessage()               {}
func (*RecipeWTag) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *RecipeWTag) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RecipeWTag) GetType() RecipeTagType {
	if m != nil {
		return m.Type
	}
	return RecipeTagType_EDIT
}

type LookupPathToSnapshotRequest struct {
	SnapId string      `protobuf:"bytes,1,opt,name=snap_id,json=snapId" json:"snap_id,omitempty"`
	Tag    *RecipeRTag `protobuf:"bytes,2,opt,name=tag" json:"tag,omitempty"`
}

func (m *LookupPathToSnapshotRequest) Reset()                    { *m = LookupPathToSnapshotRequest{} }
func (m *LookupPathToSnapshotRequest) String() string            { return proto1.CompactTextString(m) }
func (*LookupPathToSnapshotRequest) ProtoMessage()               {}
func (*LookupPathToSnapshotRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *LookupPathToSnapshotRequest) GetSnapId() string {
	if m != nil {
		return m.SnapId
	}
	return ""
}

func (m *LookupPathToSnapshotRequest) GetTag() *RecipeRTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type LookupPathToSnapshotReply struct {
	Recipe *StoredRecipe `protobuf:"bytes,1,opt,name=recipe" json:"recipe,omitempty"`
}

func (m *LookupPathToSnapshotReply) Reset()                    { *m = LookupPathToSnapshotReply{} }
func (m *LookupPathToSnapshotReply) String() string            { return proto1.CompactTextString(m) }
func (*LookupPathToSnapshotReply) ProtoMessage()               {}
func (*LookupPathToSnapshotReply) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *LookupPathToSnapshotReply) GetRecipe() *StoredRecipe {
	if m != nil {
		return m.Recipe
	}
	return nil
}

type StoredRecipe struct {
	SnapId string      `protobuf:"bytes,1,opt,name=snap_id,json=snapId" json:"snap_id,omitempty"`
	Recipe *Recipe     `protobuf:"bytes,2,opt,name=recipe" json:"recipe,omitempty"`
	Tag    *RecipeWTag `protobuf:"bytes,3,opt,name=tag" json:"tag,omitempty"`
}

func (m *StoredRecipe) Reset()                    { *m = StoredRecipe{} }
func (m *StoredRecipe) String() string            { return proto1.CompactTextString(m) }
func (*StoredRecipe) ProtoMessage()               {}
func (*StoredRecipe) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *StoredRecipe) GetSnapId() string {
	if m != nil {
		return m.SnapId
	}
	return ""
}

func (m *StoredRecipe) GetRecipe() *Recipe {
	if m != nil {
		return m.Recipe
	}
	return nil
}

func (m *StoredRecipe) GetTag() *RecipeWTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type Recipe struct {
	InputSnapId []string `protobuf:"bytes,1,rep,name=input_snap_id,json=inputSnapId" json:"input_snap_id,omitempty"`
	// Types that are valid to be assigned to Op:
	//	*Recipe_OpWriteFile
	//	*Recipe_OpRemoveFile
	//	*Recipe_OpInsertBytesFile
	//	*Recipe_OpDeleteBytesFile
	//	*Recipe_OpChmodFile
	//	*Recipe_OpRmdir
	//	*Recipe_OpSubdir
	//	*Recipe_OpDir
	//	*Recipe_OpPreserve
	//	*Recipe_OpIdentity
	//	*Recipe_OpOverlay
	//	*Recipe_OpEditFile
	//	*Recipe_OpFailure
	Op isRecipe_Op `protobuf_oneof:"op"`
}

func (m *Recipe) Reset()                    { *m = Recipe{} }
func (m *Recipe) String() string            { return proto1.CompactTextString(m) }
func (*Recipe) ProtoMessage()               {}
func (*Recipe) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

type isRecipe_Op interface{ isRecipe_Op() }

type Recipe_OpWriteFile struct {
	OpWriteFile *WriteFileOp `protobuf:"bytes,2,opt,name=op_write_file,json=opWriteFile,oneof"`
}
type Recipe_OpRemoveFile struct {
	OpRemoveFile *RemoveFileOp `protobuf:"bytes,3,opt,name=op_remove_file,json=opRemoveFile,oneof"`
}
type Recipe_OpInsertBytesFile struct {
	OpInsertBytesFile *InsertBytesFileOp `protobuf:"bytes,4,opt,name=op_insert_bytes_file,json=opInsertBytesFile,oneof"`
}
type Recipe_OpDeleteBytesFile struct {
	OpDeleteBytesFile *DeleteBytesFileOp `protobuf:"bytes,5,opt,name=op_delete_bytes_file,json=opDeleteBytesFile,oneof"`
}
type Recipe_OpChmodFile struct {
	OpChmodFile *ChmodFileOp `protobuf:"bytes,6,opt,name=op_chmod_file,json=opChmodFile,oneof"`
}
type Recipe_OpRmdir struct {
	OpRmdir *RmdirOp `protobuf:"bytes,7,opt,name=op_rmdir,json=opRmdir,oneof"`
}
type Recipe_OpSubdir struct {
	OpSubdir *SubdirOp `protobuf:"bytes,8,opt,name=op_subdir,json=opSubdir,oneof"`
}
type Recipe_OpDir struct {
	OpDir *DirOp `protobuf:"bytes,9,opt,name=op_dir,json=opDir,oneof"`
}
type Recipe_OpPreserve struct {
	OpPreserve *PreserveOp `protobuf:"bytes,10,opt,name=op_preserve,json=opPreserve,oneof"`
}
type Recipe_OpIdentity struct {
	OpIdentity *IdentityOp `protobuf:"bytes,11,opt,name=op_identity,json=opIdentity,oneof"`
}
type Recipe_OpOverlay struct {
	OpOverlay *OverlayOp `protobuf:"bytes,12,opt,name=op_overlay,json=opOverlay,oneof"`
}
type Recipe_OpEditFile struct {
	OpEditFile *EditFileOp `protobuf:"bytes,13,opt,name=op_edit_file,json=opEditFile,oneof"`
}
type Recipe_OpFailure struct {
	OpFailure *FailureOp `protobuf:"bytes,14,opt,name=op_failure,json=opFailure,oneof"`
}

func (*Recipe_OpWriteFile) isRecipe_Op()       {}
func (*Recipe_OpRemoveFile) isRecipe_Op()      {}
func (*Recipe_OpInsertBytesFile) isRecipe_Op() {}
func (*Recipe_OpDeleteBytesFile) isRecipe_Op() {}
func (*Recipe_OpChmodFile) isRecipe_Op()       {}
func (*Recipe_OpRmdir) isRecipe_Op()           {}
func (*Recipe_OpSubdir) isRecipe_Op()          {}
func (*Recipe_OpDir) isRecipe_Op()             {}
func (*Recipe_OpPreserve) isRecipe_Op()        {}
func (*Recipe_OpIdentity) isRecipe_Op()        {}
func (*Recipe_OpOverlay) isRecipe_Op()         {}
func (*Recipe_OpEditFile) isRecipe_Op()        {}
func (*Recipe_OpFailure) isRecipe_Op()         {}

func (m *Recipe) GetOp() isRecipe_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *Recipe) GetInputSnapId() []string {
	if m != nil {
		return m.InputSnapId
	}
	return nil
}

func (m *Recipe) GetOpWriteFile() *WriteFileOp {
	if x, ok := m.GetOp().(*Recipe_OpWriteFile); ok {
		return x.OpWriteFile
	}
	return nil
}

func (m *Recipe) GetOpRemoveFile() *RemoveFileOp {
	if x, ok := m.GetOp().(*Recipe_OpRemoveFile); ok {
		return x.OpRemoveFile
	}
	return nil
}

func (m *Recipe) GetOpInsertBytesFile() *InsertBytesFileOp {
	if x, ok := m.GetOp().(*Recipe_OpInsertBytesFile); ok {
		return x.OpInsertBytesFile
	}
	return nil
}

func (m *Recipe) GetOpDeleteBytesFile() *DeleteBytesFileOp {
	if x, ok := m.GetOp().(*Recipe_OpDeleteBytesFile); ok {
		return x.OpDeleteBytesFile
	}
	return nil
}

func (m *Recipe) GetOpChmodFile() *ChmodFileOp {
	if x, ok := m.GetOp().(*Recipe_OpChmodFile); ok {
		return x.OpChmodFile
	}
	return nil
}

func (m *Recipe) GetOpRmdir() *RmdirOp {
	if x, ok := m.GetOp().(*Recipe_OpRmdir); ok {
		return x.OpRmdir
	}
	return nil
}

func (m *Recipe) GetOpSubdir() *SubdirOp {
	if x, ok := m.GetOp().(*Recipe_OpSubdir); ok {
		return x.OpSubdir
	}
	return nil
}

func (m *Recipe) GetOpDir() *DirOp {
	if x, ok := m.GetOp().(*Recipe_OpDir); ok {
		return x.OpDir
	}
	return nil
}

func (m *Recipe) GetOpPreserve() *PreserveOp {
	if x, ok := m.GetOp().(*Recipe_OpPreserve); ok {
		return x.OpPreserve
	}
	return nil
}

func (m *Recipe) GetOpIdentity() *IdentityOp {
	if x, ok := m.GetOp().(*Recipe_OpIdentity); ok {
		return x.OpIdentity
	}
	return nil
}

func (m *Recipe) GetOpOverlay() *OverlayOp {
	if x, ok := m.GetOp().(*Recipe_OpOverlay); ok {
		return x.OpOverlay
	}
	return nil
}

func (m *Recipe) GetOpEditFile() *EditFileOp {
	if x, ok := m.GetOp().(*Recipe_OpEditFile); ok {
		return x.OpEditFile
	}
	return nil
}

func (m *Recipe) GetOpFailure() *FailureOp {
	if x, ok := m.GetOp().(*Recipe_OpFailure); ok {
		return x.OpFailure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Recipe) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Recipe_OneofMarshaler, _Recipe_OneofUnmarshaler, _Recipe_OneofSizer, []interface{}{
		(*Recipe_OpWriteFile)(nil),
		(*Recipe_OpRemoveFile)(nil),
		(*Recipe_OpInsertBytesFile)(nil),
		(*Recipe_OpDeleteBytesFile)(nil),
		(*Recipe_OpChmodFile)(nil),
		(*Recipe_OpRmdir)(nil),
		(*Recipe_OpSubdir)(nil),
		(*Recipe_OpDir)(nil),
		(*Recipe_OpPreserve)(nil),
		(*Recipe_OpIdentity)(nil),
		(*Recipe_OpOverlay)(nil),
		(*Recipe_OpEditFile)(nil),
		(*Recipe_OpFailure)(nil),
	}
}

func _Recipe_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Recipe)
	// op
	switch x := m.Op.(type) {
	case *Recipe_OpWriteFile:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpWriteFile); err != nil {
			return err
		}
	case *Recipe_OpRemoveFile:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpRemoveFile); err != nil {
			return err
		}
	case *Recipe_OpInsertBytesFile:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpInsertBytesFile); err != nil {
			return err
		}
	case *Recipe_OpDeleteBytesFile:
		b.EncodeVarint(5<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpDeleteBytesFile); err != nil {
			return err
		}
	case *Recipe_OpChmodFile:
		b.EncodeVarint(6<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpChmodFile); err != nil {
			return err
		}
	case *Recipe_OpRmdir:
		b.EncodeVarint(7<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpRmdir); err != nil {
			return err
		}
	case *Recipe_OpSubdir:
		b.EncodeVarint(8<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpSubdir); err != nil {
			return err
		}
	case *Recipe_OpDir:
		b.EncodeVarint(9<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpDir); err != nil {
			return err
		}
	case *Recipe_OpPreserve:
		b.EncodeVarint(10<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpPreserve); err != nil {
			return err
		}
	case *Recipe_OpIdentity:
		b.EncodeVarint(11<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpIdentity); err != nil {
			return err
		}
	case *Recipe_OpOverlay:
		b.EncodeVarint(12<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpOverlay); err != nil {
			return err
		}
	case *Recipe_OpEditFile:
		b.EncodeVarint(13<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpEditFile); err != nil {
			return err
		}
	case *Recipe_OpFailure:
		b.EncodeVarint(14<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.OpFailure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Recipe.Op has unexpected type %T", x)
	}
	return nil
}

func _Recipe_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Recipe)
	switch tag {
	case 2: // op.op_write_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(WriteFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpWriteFile{msg}
		return true, err
	case 3: // op.op_remove_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(RemoveFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpRemoveFile{msg}
		return true, err
	case 4: // op.op_insert_bytes_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(InsertBytesFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpInsertBytesFile{msg}
		return true, err
	case 5: // op.op_delete_bytes_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DeleteBytesFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpDeleteBytesFile{msg}
		return true, err
	case 6: // op.op_chmod_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(ChmodFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpChmodFile{msg}
		return true, err
	case 7: // op.op_rmdir
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(RmdirOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpRmdir{msg}
		return true, err
	case 8: // op.op_subdir
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SubdirOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpSubdir{msg}
		return true, err
	case 9: // op.op_dir
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DirOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpDir{msg}
		return true, err
	case 10: // op.op_preserve
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(PreserveOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpPreserve{msg}
		return true, err
	case 11: // op.op_identity
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(IdentityOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpIdentity{msg}
		return true, err
	case 12: // op.op_overlay
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(OverlayOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpOverlay{msg}
		return true, err
	case 13: // op.op_edit_file
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(EditFileOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpEditFile{msg}
		return true, err
	case 14: // op.op_failure
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(FailureOp)
		err := b.DecodeMessage(msg)
		m.Op = &Recipe_OpFailure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Recipe_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Recipe)
	// op
	switch x := m.Op.(type) {
	case *Recipe_OpWriteFile:
		s := proto1.Size(x.OpWriteFile)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpRemoveFile:
		s := proto1.Size(x.OpRemoveFile)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpInsertBytesFile:
		s := proto1.Size(x.OpInsertBytesFile)
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpDeleteBytesFile:
		s := proto1.Size(x.OpDeleteBytesFile)
		n += proto1.SizeVarint(5<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpChmodFile:
		s := proto1.Size(x.OpChmodFile)
		n += proto1.SizeVarint(6<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpRmdir:
		s := proto1.Size(x.OpRmdir)
		n += proto1.SizeVarint(7<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpSubdir:
		s := proto1.Size(x.OpSubdir)
		n += proto1.SizeVarint(8<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpDir:
		s := proto1.Size(x.OpDir)
		n += proto1.SizeVarint(9<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpPreserve:
		s := proto1.Size(x.OpPreserve)
		n += proto1.SizeVarint(10<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpIdentity:
		s := proto1.Size(x.OpIdentity)
		n += proto1.SizeVarint(11<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpOverlay:
		s := proto1.Size(x.OpOverlay)
		n += proto1.SizeVarint(12<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpEditFile:
		s := proto1.Size(x.OpEditFile)
		n += proto1.SizeVarint(13<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Recipe_OpFailure:
		s := proto1.Size(x.OpFailure)
		n += proto1.SizeVarint(14<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Path struct {
	// Types that are valid to be assigned to Val:
	//	*Path_Utf8
	//	*Path_Raw
	Val isPath_Val `protobuf_oneof:"val"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto1.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

type isPath_Val interface{ isPath_Val() }

type Path_Utf8 struct {
	Utf8 string `protobuf:"bytes,1,opt,name=utf8,oneof"`
}
type Path_Raw struct {
	Raw []byte `protobuf:"bytes,2,opt,name=raw,proto3,oneof"`
}

func (*Path_Utf8) isPath_Val() {}
func (*Path_Raw) isPath_Val()  {}

func (m *Path) GetVal() isPath_Val {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Path) GetUtf8() string {
	if x, ok := m.GetVal().(*Path_Utf8); ok {
		return x.Utf8
	}
	return ""
}

func (m *Path) GetRaw() []byte {
	if x, ok := m.GetVal().(*Path_Raw); ok {
		return x.Raw
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Path) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Path_OneofMarshaler, _Path_OneofUnmarshaler, _Path_OneofSizer, []interface{}{
		(*Path_Utf8)(nil),
		(*Path_Raw)(nil),
	}
}

func _Path_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Path)
	// val
	switch x := m.Val.(type) {
	case *Path_Utf8:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.Utf8)
	case *Path_Raw:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		b.EncodeRawBytes(x.Raw)
	case nil:
	default:
		return fmt.Errorf("Path.Val has unexpected type %T", x)
	}
	return nil
}

func _Path_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Path)
	switch tag {
	case 1: // val.utf8
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Val = &Path_Utf8{x}
		return true, err
	case 2: // val.raw
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Val = &Path_Raw{x}
		return true, err
	default:
		return false, nil
	}
}

func _Path_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Path)
	// val
	switch x := m.Val.(type) {
	case *Path_Utf8:
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Utf8)))
		n += len(x.Utf8)
	case *Path_Raw:
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Raw)))
		n += len(x.Raw)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Writes an entire file contents.
// Creates a new file if necessary, and overwrites any file that exists.
type WriteFileOp struct {
	Path       *Path    `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Data       []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Executable bool     `protobuf:"varint,3,opt,name=executable" json:"executable,omitempty"`
	Type       FileType `protobuf:"varint,4,opt,name=type,enum=wm.data.db.FileType" json:"type,omitempty"`
}

func (m *WriteFileOp) Reset()                    { *m = WriteFileOp{} }
func (m *WriteFileOp) String() string            { return proto1.CompactTextString(m) }
func (*WriteFileOp) ProtoMessage()               {}
func (*WriteFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

func (m *WriteFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *WriteFileOp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *WriteFileOp) GetExecutable() bool {
	if m != nil {
		return m.Executable
	}
	return false
}

func (m *WriteFileOp) GetType() FileType {
	if m != nil {
		return m.Type
	}
	return FileType_REGULAR
}

type EditFileOp struct {
	Path    *Path             `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Splices []*EditFileSplice `protobuf:"bytes,2,rep,name=splices" json:"splices,omitempty"`
}

func (m *EditFileOp) Reset()                    { *m = EditFileOp{} }
func (m *EditFileOp) String() string            { return proto1.CompactTextString(m) }
func (*EditFileOp) ProtoMessage()               {}
func (*EditFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *EditFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *EditFileOp) GetSplices() []*EditFileSplice {
	if m != nil {
		return m.Splices
	}
	return nil
}

type EditFileSplice struct {
	// The index to start splicing at.
	Index int64 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	// Types that are valid to be assigned to Edit:
	//	*EditFileSplice_Data
	//	*EditFileSplice_DeleteCount
	Edit isEditFileSplice_Edit `protobuf_oneof:"edit"`
}

func (m *EditFileSplice) Reset()                    { *m = EditFileSplice{} }
func (m *EditFileSplice) String() string            { return proto1.CompactTextString(m) }
func (*EditFileSplice) ProtoMessage()               {}
func (*EditFileSplice) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

type isEditFileSplice_Edit interface{ isEditFileSplice_Edit() }

type EditFileSplice_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}
type EditFileSplice_DeleteCount struct {
	DeleteCount int64 `protobuf:"varint,3,opt,name=delete_count,json=deleteCount,oneof"`
}

func (*EditFileSplice_Data) isEditFileSplice_Edit()        {}
func (*EditFileSplice_DeleteCount) isEditFileSplice_Edit() {}

func (m *EditFileSplice) GetEdit() isEditFileSplice_Edit {
	if m != nil {
		return m.Edit
	}
	return nil
}

func (m *EditFileSplice) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *EditFileSplice) GetData() []byte {
	if x, ok := m.GetEdit().(*EditFileSplice_Data); ok {
		return x.Data
	}
	return nil
}

func (m *EditFileSplice) GetDeleteCount() int64 {
	if x, ok := m.GetEdit().(*EditFileSplice_DeleteCount); ok {
		return x.DeleteCount
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EditFileSplice) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _EditFileSplice_OneofMarshaler, _EditFileSplice_OneofUnmarshaler, _EditFileSplice_OneofSizer, []interface{}{
		(*EditFileSplice_Data)(nil),
		(*EditFileSplice_DeleteCount)(nil),
	}
}

func _EditFileSplice_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*EditFileSplice)
	// edit
	switch x := m.Edit.(type) {
	case *EditFileSplice_Data:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		b.EncodeRawBytes(x.Data)
	case *EditFileSplice_DeleteCount:
		b.EncodeVarint(3<<3 | proto1.WireVarint)
		b.EncodeVarint(uint64(x.DeleteCount))
	case nil:
	default:
		return fmt.Errorf("EditFileSplice.Edit has unexpected type %T", x)
	}
	return nil
}

func _EditFileSplice_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*EditFileSplice)
	switch tag {
	case 2: // edit.data
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Edit = &EditFileSplice_Data{x}
		return true, err
	case 3: // edit.delete_count
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Edit = &EditFileSplice_DeleteCount{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _EditFileSplice_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*EditFileSplice)
	// edit
	switch x := m.Edit.(type) {
	case *EditFileSplice_Data:
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case *EditFileSplice_DeleteCount:
		n += proto1.SizeVarint(3<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.DeleteCount))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Insert bytes into an existing file. Should error if the file doesn't exist
// or if we're inserting at a bad index.
type InsertBytesFileOp struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// The index to start splicing at.
	Index int64 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	// The bytes to insert.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *InsertBytesFileOp) Reset()                    { *m = InsertBytesFileOp{} }
func (m *InsertBytesFileOp) String() string            { return proto1.CompactTextString(m) }
func (*InsertBytesFileOp) ProtoMessage()               {}
func (*InsertBytesFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

func (m *InsertBytesFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *InsertBytesFileOp) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *InsertBytesFileOp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Delete bytes from an existing file. Should error if the file doesn't exist
// or if there aren't enough bytes to delete.
type DeleteBytesFileOp struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// The index to start splicing at.
	Index int64 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	// The number of bytes to delete.
	DeleteCount int64 `protobuf:"varint,3,opt,name=delete_count,json=deleteCount" json:"delete_count,omitempty"`
}

func (m *DeleteBytesFileOp) Reset()                    { *m = DeleteBytesFileOp{} }
func (m *DeleteBytesFileOp) String() string            { return proto1.CompactTextString(m) }
func (*DeleteBytesFileOp) ProtoMessage()               {}
func (*DeleteBytesFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{11} }

func (m *DeleteBytesFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *DeleteBytesFileOp) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *DeleteBytesFileOp) GetDeleteCount() int64 {
	if m != nil {
		return m.DeleteCount
	}
	return 0
}

// Remove a file.
// Should error if the file doesn't exist.
type RemoveFileOp struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *RemoveFileOp) Reset()                    { *m = RemoveFileOp{} }
func (m *RemoveFileOp) String() string            { return proto1.CompactTextString(m) }
func (*RemoveFileOp) ProtoMessage()               {}
func (*RemoveFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{12} }

func (m *RemoveFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// Modify permission bits on a file.
// Should error if the file doesn't exist.
type ChmodFileOp struct {
	Path       *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Executable bool  `protobuf:"varint,2,opt,name=executable" json:"executable,omitempty"`
}

func (m *ChmodFileOp) Reset()                    { *m = ChmodFileOp{} }
func (m *ChmodFileOp) String() string            { return proto1.CompactTextString(m) }
func (*ChmodFileOp) ProtoMessage()               {}
func (*ChmodFileOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{13} }

func (m *ChmodFileOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ChmodFileOp) GetExecutable() bool {
	if m != nil {
		return m.Executable
	}
	return false
}

// Remove a subdirectory (or empty string path means remove all)
type RmdirOp struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *RmdirOp) Reset()                    { *m = RmdirOp{} }
func (m *RmdirOp) String() string            { return proto1.CompactTextString(m) }
func (*RmdirOp) ProtoMessage()               {}
func (*RmdirOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{14} }

func (m *RmdirOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// Select a subdirectory from the input.
// Path may contain a / .
type SubdirOp struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *SubdirOp) Reset()                    { *m = SubdirOp{} }
func (m *SubdirOp) String() string            { return proto1.CompactTextString(m) }
func (*SubdirOp) ProtoMessage()               {}
func (*SubdirOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{15} }

func (m *SubdirOp) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// Create a new directory with the names in names, each pointing at
// the Input with the same index.
type DirOp struct {
	Name []*Path `protobuf:"bytes,1,rep,name=name" json:"name,omitempty"`
}

func (m *DirOp) Reset()                    { *m = DirOp{} }
func (m *DirOp) String() string            { return proto1.CompactTextString(m) }
func (*DirOp) ProtoMessage()               {}
func (*DirOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{16} }

func (m *DirOp) GetName() []*Path {
	if m != nil {
		return m.Name
	}
	return nil
}

// Creates a new Snapshot that has the files from input whose names match patterns
// if strip_contents is true, the files will be empty (but exist)
type PreserveOp struct {
	Patterns      []string `protobuf:"bytes,1,rep,name=patterns" json:"patterns,omitempty"`
	StripContents bool     `protobuf:"varint,2,opt,name=strip_contents,json=stripContents" json:"strip_contents,omitempty"`
}

func (m *PreserveOp) Reset()                    { *m = PreserveOp{} }
func (m *PreserveOp) String() string            { return proto1.CompactTextString(m) }
func (*PreserveOp) ProtoMessage()               {}
func (*PreserveOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{17} }

func (m *PreserveOp) GetPatterns() []string {
	if m != nil {
		return m.Patterns
	}
	return nil
}

func (m *PreserveOp) GetStripContents() bool {
	if m != nil {
		return m.StripContents
	}
	return false
}

// Creates a new Snapshot by doing nothing. Used to connect equivalent snapshots.
type IdentityOp struct {
}

func (m *IdentityOp) Reset()                    { *m = IdentityOp{} }
func (m *IdentityOp) String() string            { return proto1.CompactTextString(m) }
func (*IdentityOp) ProtoMessage()               {}
func (*IdentityOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{18} }

// Overlays multiple snapshots like in an overlay filesystem.
type OverlayOp struct {
}

func (m *OverlayOp) Reset()                    { *m = OverlayOp{} }
func (m *OverlayOp) String() string            { return proto1.CompactTextString(m) }
func (*OverlayOp) ProtoMessage()               {}
func (*OverlayOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{19} }

// Simulate a failure. Evaluators should always throw an error.
type FailureOp struct {
	Msg string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
}

func (m *FailureOp) Reset()                    { *m = FailureOp{} }
func (m *FailureOp) String() string            { return proto1.CompactTextString(m) }
func (*FailureOp) ProtoMessage()               {}
func (*FailureOp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{20} }

func (m *FailureOp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto1.RegisterType((*RecipeRTag)(nil), "wm.data.db.RecipeRTag")
	proto1.RegisterType((*RecipeWTag)(nil), "wm.data.db.RecipeWTag")
	proto1.RegisterType((*LookupPathToSnapshotRequest)(nil), "wm.data.db.LookupPathToSnapshotRequest")
	proto1.RegisterType((*LookupPathToSnapshotReply)(nil), "wm.data.db.LookupPathToSnapshotReply")
	proto1.RegisterType((*StoredRecipe)(nil), "wm.data.db.StoredRecipe")
	proto1.RegisterType((*Recipe)(nil), "wm.data.db.Recipe")
	proto1.RegisterType((*Path)(nil), "wm.data.db.Path")
	proto1.RegisterType((*WriteFileOp)(nil), "wm.data.db.WriteFileOp")
	proto1.RegisterType((*EditFileOp)(nil), "wm.data.db.EditFileOp")
	proto1.RegisterType((*EditFileSplice)(nil), "wm.data.db.EditFileSplice")
	proto1.RegisterType((*InsertBytesFileOp)(nil), "wm.data.db.InsertBytesFileOp")
	proto1.RegisterType((*DeleteBytesFileOp)(nil), "wm.data.db.DeleteBytesFileOp")
	proto1.RegisterType((*RemoveFileOp)(nil), "wm.data.db.RemoveFileOp")
	proto1.RegisterType((*ChmodFileOp)(nil), "wm.data.db.ChmodFileOp")
	proto1.RegisterType((*RmdirOp)(nil), "wm.data.db.RmdirOp")
	proto1.RegisterType((*SubdirOp)(nil), "wm.data.db.SubdirOp")
	proto1.RegisterType((*DirOp)(nil), "wm.data.db.DirOp")
	proto1.RegisterType((*PreserveOp)(nil), "wm.data.db.PreserveOp")
	proto1.RegisterType((*IdentityOp)(nil), "wm.data.db.IdentityOp")
	proto1.RegisterType((*OverlayOp)(nil), "wm.data.db.OverlayOp")
	proto1.RegisterType((*FailureOp)(nil), "wm.data.db.FailureOp")
	proto1.RegisterEnum("wm.data.db.FileType", FileType_name, FileType_value)
	proto1.RegisterEnum("wm.data.db.RecipeTagType", RecipeTagType_name, RecipeTagType_value)
}

func init() { proto1.RegisterFile("data/db/proto/recipes.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 1004 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdb, 0x6e, 0xdb, 0x36,
	0x18, 0x8e, 0x2d, 0xc5, 0x87, 0x5f, 0xb6, 0xe1, 0x70, 0xd9, 0xaa, 0xb6, 0xe8, 0x90, 0x69, 0x1d,
	0x60, 0x04, 0xa8, 0x9d, 0xa5, 0xdd, 0x19, 0x03, 0xd6, 0x1c, 0xba, 0x18, 0x4d, 0x9a, 0x80, 0xf6,
	0x10, 0x6c, 0x37, 0x9a, 0x6c, 0x31, 0x36, 0x31, 0x59, 0xe4, 0x24, 0x3a, 0xa9, 0x2f, 0xf6, 0x10,
	0x7b, 0xae, 0xbd, 0xd4, 0x40, 0x8a, 0x92, 0xa5, 0x28, 0x05, 0x0c, 0x6c, 0x37, 0x89, 0xff, 0xc3,
	0xf7, 0xfd, 0x07, 0x91, 0x9f, 0x04, 0x4f, 0x7d, 0x4f, 0x78, 0x03, 0x7f, 0x32, 0xe0, 0x11, 0x13,
	0x6c, 0x10, 0x91, 0x29, 0xe5, 0x24, 0xee, 0x2b, 0x0b, 0xc1, 0xdd, 0xa2, 0x2f, 0xe3, 0x7d, 0x7f,
	0xe2, 0xbc, 0x05, 0xc0, 0x2a, 0x88, 0xc7, 0xde, 0x0c, 0x75, 0xa0, 0x4a, 0x7d, 0xbb, 0xb2, 0x57,
	0xe9, 0x35, 0x71, 0x95, 0xfa, 0xe8, 0x05, 0x98, 0x62, 0xc5, 0x89, 0x5d, 0xdd, 0xab, 0xf4, 0x3a,
	0x87, 0x8f, 0xfb, 0x6b, 0x60, 0x3f, 0x41, 0x8d, 0xbd, 0xd9, 0x78, 0xc5, 0x09, 0x56, 0x69, 0x6b,
	0xb2, 0xeb, 0xff, 0x81, 0xec, 0x77, 0x78, 0x7a, 0xce, 0xd8, 0x1f, 0x4b, 0x7e, 0xe5, 0x89, 0xf9,
	0x98, 0x8d, 0x42, 0x8f, 0xc7, 0x73, 0x26, 0x30, 0xf9, 0x73, 0x49, 0x62, 0x81, 0x1e, 0x41, 0x3d,
	0x0e, 0x3d, 0xee, 0x66, 0x25, 0x6a, 0xd2, 0x1c, 0xfa, 0xa8, 0x07, 0x86, 0xf0, 0x66, 0xaa, 0x8a,
	0x75, 0xf8, 0x49, 0xb9, 0x8a, 0x1c, 0x14, 0xcb, 0x14, 0xe7, 0x02, 0x1e, 0x3f, 0x5c, 0x81, 0x07,
	0x2b, 0x74, 0x00, 0xb5, 0x64, 0x6b, 0x8a, 0xde, 0x3a, 0xb4, 0xf3, 0x4c, 0x23, 0xc1, 0x22, 0xe2,
	0x6b, 0x3e, 0x9d, 0xe7, 0xfc, 0x05, 0xad, 0xbc, 0xff, 0xc3, 0x1d, 0xee, 0x67, 0xd4, 0x49, 0x93,
	0xe8, 0x81, 0x26, 0x75, 0x46, 0x3a, 0x8d, 0xf1, 0xa1, 0x69, 0xae, 0xb3, 0x69, 0xfe, 0xa9, 0x41,
	0x4d, 0x57, 0x76, 0xa0, 0x4d, 0x43, 0xbe, 0x14, 0xee, 0xba, 0xbe, 0xd1, 0x6b, 0x62, 0x4b, 0x39,
	0x47, 0x49, 0x13, 0x3f, 0x42, 0x9b, 0x71, 0xf7, 0x2e, 0xa2, 0x82, 0xb8, 0x37, 0x34, 0x48, 0x7b,
	0x79, 0x94, 0x2f, 0x71, 0x2d, 0xa3, 0x6f, 0x68, 0x40, 0x2e, 0xf9, 0xd9, 0x16, 0xb6, 0x18, 0xcf,
	0x1c, 0xe8, 0x27, 0xe8, 0x30, 0xee, 0x46, 0x64, 0xc1, 0x6e, 0x35, 0xde, 0x28, 0xaf, 0x09, 0xab,
	0x70, 0x46, 0xd0, 0x62, 0x7c, 0xed, 0x41, 0x57, 0xb0, 0xcb, 0xb8, 0x4b, 0xc3, 0x98, 0x44, 0xc2,
	0x9d, 0xac, 0x04, 0x89, 0x13, 0x1e, 0x53, 0xf1, 0x3c, 0xcb, 0xf3, 0x0c, 0x55, 0xd2, 0x91, 0xcc,
	0xc9, 0xc8, 0x76, 0x18, 0xbf, 0xe7, 0xd6, 0x8c, 0x3e, 0x09, 0x88, 0x20, 0x79, 0xc6, 0xed, 0x32,
	0xe3, 0x89, 0x4a, 0x2a, 0x31, 0xde, 0x73, 0xeb, 0x25, 0x4d, 0xe7, 0x0b, 0xe6, 0x27, 0x54, 0xb5,
	0xf2, 0x92, 0x8e, 0x65, 0x34, 0xbf, 0xa4, 0xcc, 0x81, 0x0e, 0xa0, 0x21, 0x97, 0xb4, 0xf0, 0x69,
	0x64, 0xd7, 0x15, 0xf2, 0xa3, 0xc2, 0x7a, 0x64, 0x40, 0xa1, 0xea, 0x8c, 0x2b, 0x03, 0xbd, 0x84,
	0x26, 0xe3, 0x6e, 0xbc, 0x9c, 0x48, 0x48, 0x43, 0x41, 0x76, 0x0b, 0x07, 0x4f, 0x45, 0x14, 0xa6,
	0xc1, 0x78, 0x62, 0xc9, 0xf3, 0x24, 0xe7, 0xa6, 0x91, 0xdd, 0x54, 0x88, 0x9d, 0xc2, 0xa4, 0x3a,
	0x7d, 0x9b, 0xf1, 0x13, 0x1a, 0xa1, 0xef, 0xc0, 0x62, 0xdc, 0xe5, 0x11, 0x89, 0x49, 0x74, 0x4b,
	0x6c, 0x28, 0x9f, 0xab, 0x2b, 0x1d, 0x53, 0x28, 0x60, 0x3c, 0xb5, 0x35, 0x94, 0xfa, 0x24, 0x14,
	0x54, 0xac, 0x6c, 0xab, 0x0c, 0x1d, 0xea, 0x58, 0x0a, 0x4d, 0x6d, 0xf4, 0x35, 0x00, 0xe3, 0x2e,
	0xbb, 0x25, 0x51, 0xe0, 0xad, 0xec, 0x96, 0x42, 0x7e, 0x9c, 0x47, 0x5e, 0x26, 0x21, 0x05, 0x6c,
	0x32, 0xae, 0x4d, 0xf4, 0x3d, 0xb4, 0x18, 0x77, 0x89, 0x4f, 0x45, 0xb2, 0xfe, 0x76, 0xb9, 0xe6,
	0xa9, 0x4f, 0x45, 0xb6, 0x7d, 0x60, 0x3c, 0xb5, 0x75, 0xcd, 0x1b, 0x8f, 0x06, 0xcb, 0x88, 0xd8,
	0x9d, 0x72, 0xcd, 0x37, 0x49, 0x28, 0xad, 0xa9, 0xcd, 0x23, 0x13, 0xaa, 0x8c, 0x3b, 0xdf, 0x80,
	0x29, 0x55, 0x01, 0xed, 0x82, 0xb9, 0x14, 0x37, 0xdf, 0x26, 0x37, 0xf8, 0x6c, 0x0b, 0x2b, 0x0b,
	0x21, 0x30, 0x22, 0xef, 0x4e, 0x5d, 0x99, 0xd6, 0xd9, 0x16, 0x96, 0xc6, 0xd1, 0x36, 0x18, 0xb7,
	0x5e, 0xe0, 0xfc, 0x5d, 0x01, 0x2b, 0x77, 0x6f, 0xd0, 0x73, 0x30, 0xb9, 0x27, 0xe6, 0x5a, 0x45,
	0xba, 0x85, 0x4d, 0x7b, 0x62, 0x8e, 0x55, 0x14, 0x21, 0x30, 0xa5, 0x37, 0x61, 0xc4, 0xea, 0x37,
	0xfa, 0x14, 0x80, 0xbc, 0x27, 0xd3, 0xa5, 0xf0, 0x26, 0xfa, 0x7a, 0x35, 0x70, 0xce, 0x83, 0x7a,
	0x5a, 0x4f, 0x4d, 0xa5, 0xa7, 0x85, 0x63, 0x22, 0x6b, 0xe7, 0xa4, 0x74, 0x0e, 0xb0, 0x5e, 0xd3,
	0x86, 0x1d, 0xbd, 0x82, 0x7a, 0xcc, 0x03, 0x3a, 0x25, 0xb1, 0x5d, 0xdd, 0x33, 0x7a, 0xd6, 0xe1,
	0x93, 0x87, 0xb6, 0x3e, 0x52, 0x29, 0x38, 0x4d, 0x75, 0x28, 0x74, 0x8a, 0x21, 0xb4, 0x0b, 0xdb,
	0x34, 0xf4, 0xc9, 0x7b, 0x55, 0xce, 0xc0, 0x89, 0x21, 0xd7, 0xba, 0x9e, 0x57, 0xae, 0x55, 0x4d,
	0xfc, 0x39, 0xb4, 0xf4, 0xed, 0x9d, 0xb2, 0x65, 0x28, 0xd4, 0xcc, 0x86, 0xbc, 0x54, 0x89, 0xf7,
	0x58, 0x3a, 0x8f, 0x6a, 0x60, 0xca, 0x03, 0xe1, 0x4c, 0x61, 0xa7, 0xa4, 0x0b, 0x1b, 0xce, 0x96,
	0xf5, 0x54, 0xcd, 0xf7, 0x94, 0x3e, 0x03, 0x63, 0xfd, 0x0c, 0x9c, 0x08, 0x76, 0x4a, 0x52, 0xf1,
	0x9f, 0x8a, 0x7c, 0xf6, 0xd0, 0x88, 0x85, 0x01, 0x9d, 0x57, 0xd0, 0xca, 0x0b, 0xe7, 0x66, 0xe5,
	0x9c, 0x11, 0x58, 0x39, 0x25, 0xda, 0xb0, 0xc7, 0xe2, 0x11, 0xab, 0xde, 0x3f, 0x62, 0xce, 0x00,
	0xea, 0x5a, 0xa4, 0x36, 0xec, 0xe2, 0x00, 0x1a, 0xa9, 0x44, 0x6d, 0x88, 0x78, 0x01, 0xdb, 0x27,
	0x69, 0x7a, 0xe8, 0x2d, 0x88, 0x7a, 0x57, 0x3d, 0x98, 0x2e, 0xa3, 0xce, 0x25, 0xc0, 0x5a, 0xa0,
	0xd0, 0x13, 0x68, 0x70, 0x4f, 0x08, 0x12, 0x85, 0xb1, 0x7e, 0xc7, 0x65, 0x36, 0xfa, 0x02, 0x3a,
	0xb1, 0x88, 0x28, 0x77, 0xa7, 0x2c, 0x14, 0x24, 0x14, 0xb1, 0x9e, 0xaf, 0xad, 0xbc, 0xc7, 0xda,
	0xe9, 0xb4, 0x00, 0xd6, 0xb2, 0xe5, 0x58, 0xd0, 0xcc, 0xa4, 0xc8, 0x79, 0x06, 0xcd, 0x4c, 0x23,
	0x50, 0x17, 0x8c, 0x45, 0x3c, 0xd3, 0x6f, 0x72, 0xf9, 0x73, 0xff, 0x39, 0x34, 0xd2, 0x7b, 0x86,
	0x2c, 0xa8, 0xe3, 0xd3, 0x9f, 0x7f, 0x39, 0x7f, 0x8d, 0xbb, 0x5b, 0xd2, 0x18, 0xfd, 0x7a, 0x71,
	0x3e, 0x7c, 0xf7, 0xb6, 0x5b, 0xd9, 0xff, 0x0a, 0xda, 0x85, 0xaf, 0x1b, 0xd4, 0x00, 0xf3, 0xf4,
	0x64, 0x38, 0x4e, 0xf2, 0x2e, 0xaf, 0xc6, 0xc3, 0x8b, 0xd7, 0xe7, 0xdd, 0x0a, 0x6a, 0x43, 0x13,
	0x9f, 0x5e, 0xe3, 0xe1, 0x78, 0x7c, 0xfa, 0xae, 0x6b, 0x1c, 0x7d, 0xf9, 0xdb, 0x60, 0x46, 0xc5,
	0x7c, 0x39, 0xe9, 0x4f, 0xd9, 0x62, 0x70, 0x47, 0x43, 0x7f, 0x41, 0x83, 0x80, 0x84, 0xb3, 0xc1,
	0x82, 0xc6, 0xf3, 0x41, 0xe1, 0xf3, 0xee, 0x07, 0xf5, 0x77, 0x52, 0x53, 0xff, 0x5e, 0xfe, 0x1b,
	0x00, 0x00, 0xff, 0xff, 0x26, 0xdc, 0xaf, 0xf2, 0xfc, 0x09, 0x00, 0x00,
}
